<!DOCTYPE html>
<html lang="de">
<head>
  <meta charset="UTF-8" />
  <title>Session Feedback</title>
  <style>
    body {
      font-family: Arial, sans-serif;
      max-width: 600px;
      margin: 2rem auto;
      padding: 1rem;
    }
    h1 {
      text-align: center;
    }
    .question {
      background: #f4f6f7;
      border-radius: 8px;
      padding: 1rem;
      margin-bottom: 1rem;
    }
    .question label {
      display: block;
      font-weight: bold;
      margin-bottom: 0.5rem;
    }
    select, input[type="radio"], textarea {
      margin-top: 0.3rem;
    }
    textarea {
      width: 100%;
      height: 80px;
      box-sizing: border-box;
      resize: vertical;
      padding: 0.5rem;
    }
    .submit-btn {
      background-color: #27ae60;
      color: white;
      border: none;
      padding: 0.7rem 2rem;
      font-size: 1rem;
      border-radius: 5px;
      cursor: pointer;
      display: block;
      margin: 1rem auto;
    }
    .submit-btn:hover {
      background-color: #219150;
    }
    .message {
      text-align: center;
      font-weight: bold;
      margin-top: 1rem;
      color: green;
    }
    .hidden {
      display: none;
    }
    #chatContainer {
      border: 1px solid #ccc;
      height: 250px;
      overflow-y: auto;
      padding: 10px;
      margin-top: 1rem;
      background: #fafafa;
    }
    #chatInput {
      width: 80%;
      padding: 0.5rem;
      font-size: 1rem;
      box-sizing: border-box;
      border-radius: 4px;
      border: 1px solid #ccc;
    }
    #sendChatBtn {
      padding: 0.5rem 1rem;
      font-size: 1rem;
      cursor: pointer;
      background-color: #2980b9;
      color: white;
      border: none;
      border-radius: 4px;
      margin-left: 5px;
    }
    #sendChatBtn:hover {
      background-color: #2771a3;
    }
    .chat-message {
      padding: 5px 0;
      border-bottom: 1px solid #eee;
    }
    /* Neue Styles f√ºr Sternbewertung */
    .star-rating {
      display: flex;
      gap: 5px;
      margin-top: 0.5rem;
    }
    .star {
      font-size: 2rem;
      cursor: pointer;
      transition: transform 0.2s;
      color: #ddd;
    }
    .star:hover {
      transform: scale(1.2);
    }
    .star.filled {
      color: #f1c40f;
    }
    .star.half-filled {
      color: #f1c40f;
      clip-path: inset(0 50% 0 0);
    }
  </style>
</head>
<body>

  <h1>Feedback zur Session</h1>
  <form id="feedbackForm">
    <div id="questionsContainer"></div>
    <button type="submit" class="submit-btn">Feedback abschicken</button>
  </form>

  <div id="message" class="message hidden"></div>

  <h2>Live Chat</h2>
  <div id="chatContainer"></div>
  <input type="text" id="chatInput" placeholder="Frage stellen..." />
  <button id="sendChatBtn">Senden</button>

  <script>
    let isUserTyping = false;
    const form = document.getElementById('feedbackForm');
    const messageDiv = document.getElementById('message');
    let sessionChangesSource = null; // F√ºr Live-Updates

    function getSessionId() {
      const params = new URLSearchParams(window.location.search);
      return params.get('id');
    }

    async function loadSession(sessionId) {
      try {
        const res = await fetch(`http://localhost:5984/gmci/${encodeURIComponent(sessionId)}`);
        if (!res.ok) throw new Error('Session nicht gefunden');
        const session = await res.json();
        return session;
      } catch (err) {
        alert('Fehler beim Laden der Session: ' + err.message);
        throw err;
      }
    }

    function createQuestionInput(question, qIndex) {
      const container = document.createElement('div');
      container.classList.add('question');

      const label = document.createElement('label');
      label.setAttribute('for', `q-${qIndex}`);
      label.textContent = question.text;
      container.appendChild(label);

      let input;

      if (question.type === 'stars') {
        // NEU: Sternbewertung mit interaktiven Sternen
        input = document.createElement('div');
        input.id = `q-${qIndex}`;
        input.name = `q-${qIndex}`;
        input.required = true;
        input.classList.add('star-rating-container');
        
        // Erstelle 5 leere Sterne
        const starContainer = document.createElement('div');
        starContainer.classList.add('star-rating');
        
        const stars = [];
        for (let i = 1; i <= 5; i++) {
          const star = document.createElement('span');
          star.classList.add('star');
          star.textContent = '‚òÖ';
          star.dataset.value = i;
          
          star.addEventListener('click', function() {
            // Setze alle Sterne bis zum geklickten Stern als gef√ºllt
            stars.forEach((s, index) => {
              if (index < i) {
                s.classList.add('filled');
                s.classList.remove('half-filled');
              } else {
                s.classList.remove('filled', 'half-filled');
              }
            });
            
            // Setze den Wert f√ºr das Formular
            input.value = i;
          });
          
          starContainer.appendChild(star);
          stars.push(star);
        }
        
        // Verstecktes Input-Feld f√ºr das Formular
        const hiddenInput = document.createElement('input');
        hiddenInput.type = 'hidden';
        hiddenInput.name = `q-${qIndex}`;
        hiddenInput.id = `q-${qIndex}-hidden`;
        input.appendChild(hiddenInput);
        
        input.appendChild(starContainer);
        
        // Setze den Wert beim Klick
        input.addEventListener('click', function(e) {
          if (e.target.classList.contains('star')) {
            const value = parseInt(e.target.dataset.value);
            hiddenInput.value = value;
          }
        });
      } else if (question.type === 'emoji') {
        input = document.createElement('div');
        input.id = `q-${qIndex}`;
        input.name = `q-${qIndex}`;
        input.required = true;

        const emojis = ['üòû', 'üòê', 'üòÄ'];
        emojis.forEach((emoji, idx) => {
          const radioId = `q-${qIndex}-${idx}`;

          const radio = document.createElement('input');
          radio.type = 'radio';
          radio.id = radioId;
          radio.name = `q-${qIndex}`;
          radio.value = emoji;
          radio.required = true;

          const labelRadio = document.createElement('label');
          labelRadio.htmlFor = radioId;
          labelRadio.textContent = emoji;
          labelRadio.style.fontSize = '1.5rem';
          labelRadio.style.marginRight = '1rem';
          labelRadio.style.cursor = 'pointer';

          input.appendChild(radio);
          input.appendChild(labelRadio);
        });
      } else if (question.type === 'text') {
        input = document.createElement('textarea');
        input.id = `q-${qIndex}`;
        input.name = `q-${qIndex}`;
        input.rows = 4;
        input.placeholder = 'Deine Antwort...';
        input.required = true;
      } else if (question.type === 'multiple-choice') {
        // CORRECTED: Multiple Choice sollte eine Select-Box sein
        input = document.createElement('select');
        input.name = `q-${qIndex}`;
        input.id = `q-${qIndex}`;
        input.required = true;
        
        // Optionen hinzuf√ºgen
        const option = document.createElement('option');
        option.value = '';
        option.textContent = 'Bitte w√§hlen...';
        option.disabled = true;
        option.selected = true;
        input.appendChild(option);
        
        if (question.options && question.options.length > 0) {
          question.options.forEach(optionValue => {
            const option = document.createElement('option');
            option.value = optionValue;
            option.textContent = optionValue;
            input.appendChild(option);
          });
        }
      } else {
        input = document.createElement('input');
        input.type = 'text';
        input.id = `q-${qIndex}`;
        input.name = `q-${qIndex}`;
        input.required = true;
      }

      container.appendChild(input);
      return container;
    }

    async function refresh() {
      if (isUserTyping) return;

      const sessionId = getSessionId();
      if (!sessionId) return;

      try {
          const session = await loadSession(sessionId);
          const questionsContainer = document.getElementById('questionsContainer');
          questionsContainer.innerHTML = '';

          // Sicherstellen, dass unlockedQuestions ein Array ist
          const unlockedIds = Array.isArray(session.unlockedQuestions) ? session.unlockedQuestions : [];
          
          console.log('Session:', session);
          console.log('Unlocked Questions:', unlockedIds);

          if (!Array.isArray(session.questions) || session.questions.length === 0) {
              questionsContainer.innerHTML = '<p>Zurzeit sind keine Fragen zum Feedback verf√ºgbar.</p>';
              document.querySelector('button[type=submit]').disabled = true;
              return;
          }

          let hasUnlockedQuestions = false;
          
          session.questions.forEach((q, i) => {
              // Nur Fragen anzeigen, die freigeschaltet sind
              if (unlockedIds.includes(q.id)) {
                  const questionInput = createQuestionInput(q, i);
                  questionsContainer.appendChild(questionInput);
                  hasUnlockedQuestions = true;
              }
          });

          if (!hasUnlockedQuestions && session.questions.length > 0) {
              questionsContainer.innerHTML = '<p>Zurzeit sind keine Fragen zum Feedback freigegeben.</p>';
              document.querySelector('button[type=submit]').disabled = true;
          } else if (hasUnlockedQuestions) {
              document.querySelector('button[type=submit]').disabled = false;
          }

      } catch (error) {
          console.error("Fehler beim Aktualisieren: ", error);
      }
    }

    // Funktion zum Einrichten von Live-Updates f√ºr Session-√Ñnderungen
    function setupSessionLiveUpdates() {
      const sessionId = getSessionId();
      if (!sessionId) return;

      // Schlie√üe bestehende Verbindung, falls vorhanden
      if (sessionChangesSource) {
        sessionChangesSource.close();
      }

      // √ñffne neue EventSource-Verbindung
      sessionChangesSource = new EventSource(`http://localhost:5984/gmci/_changes?feed=eventsource&since=now&include_docs=true`);
      
      sessionChangesSource.onmessage = event => {
        const change = JSON.parse(event.data);
        const doc = change.doc;
        
        // Pr√ºfe, ob die √Ñnderung zur aktuellen Session geh√∂rt
        if (doc.type === 'session' && doc._id === sessionId) {
          console.log('Session-√Ñnderung erkannt, aktualisiere Fragen...');
          refresh(); // Aktualisiere die Fragen automatisch
        }
        
        // Auch f√ºr Chat-Nachrichten
        if (doc.type === 'chat' && doc.sessionId === sessionId) {
          // Chat-Updates werden bereits separat behandelt
        }
      };

      sessionChangesSource.onerror = function(err) {
        console.error('EventSource Fehler:', err);
        // Versuche, die Verbindung neu aufzubauen
        setTimeout(setupSessionLiveUpdates, 5000);
      };
    }

    form.addEventListener('submit', async function(e) {
      e.preventDefault();

      const formData = new FormData(form);
      let answers = {};
      
      // Hier m√ºssen wir die korrekten Keys verwenden
      // Wir verwenden die echten Frage-IDs aus der Session
      const sessionId = getSessionId();
      
      try {
        // Session laden, um die echten Frage-IDs zu erhalten
        const sessionRes = await fetch(`http://localhost:5984/gmci/${encodeURIComponent(sessionId)}`);
        const session = await sessionRes.json();
        
        // Map f√ºr die Key-Zuordnung
        const questionIdMap = {};
        session.questions.forEach((question, index) => {
          questionIdMap[`q-${index}`] = question.id;
        });
        
        // Jetzt die Antworten mit korrekten Keys erstellen
        for (const [key, value] of formData.entries()) {
          // Wenn der Key mit q- beginnt, ersetze ihn durch die echte Frage-ID
          if (key.startsWith('q-')) {
            const realQuestionId = questionIdMap[key];
            if (realQuestionId) {
              answers[realQuestionId] = value;
            } else {
              answers[key] = value; // Fallback
            }
          } else {
            answers[key] = value;
          }
        }
        
        console.log('Sende Feedback mit korrekten Antworten:', answers);

        const feedbackDoc = {
          type: 'feedback',
          sessionId: getSessionId(),
          timestamp: new Date().toISOString(),
          answers: answers
        };

        const response = await fetch('http://localhost:5984/gmci', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(feedbackDoc)
        });

        if (!response.ok) {
          const errorData = await response.json();
          alert('Fehler beim Absenden des Feedbacks: ' + (errorData.reason || response.statusText));
          return;
        }

        messageDiv.textContent = 'Danke f√ºr dein Feedback!';
        messageDiv.classList.remove('hidden');
        form.reset();

        // Fragen neu laden, damit sie wieder angezeigt werden
        refresh();

        // Nachricht nach 2 Sekunden ausblenden
        setTimeout(() => {
          messageDiv.classList.add('hidden');
        }, 2000);

      } catch (err) {
        alert('Fehler bei der Verbindung: ' + err.message);
      }
    });

    // Chat Funktionen

    const chatContainerStud = document.getElementById('chatContainer');
    const chatInputStud = document.getElementById('chatInput');
    const sendChatBtn = document.getElementById('sendChatBtn');

    function addChatMessageStud(text, fromModerator = false) {
      const msgDiv = document.createElement('div');
      msgDiv.classList.add('chat-message');
      msgDiv.textContent = fromModerator ? `(Moderator) ${text}` : text;
      chatContainerStud.appendChild(msgDiv);
      chatContainerStud.scrollTop = chatContainerStud.scrollHeight;
    }

    async function loadChatsStud() {
      const mangoQuery = {
        selector: { type: 'chat', sessionId: getSessionId() },
        sort: [{timestamp: 'asc'}]
      };

      const res = await fetch('http://localhost:5984/gmci/_find', {
        method: 'POST',
        headers: {'Content-Type':'application/json'},
        body: JSON.stringify(mangoQuery)
      });
      const data = await res.json();
      data.docs.forEach(chat => addChatMessageStud(chat.message, chat.fromModerator));
    }

    const sourceStud = new EventSource(`http://localhost:5984/gmci/_changes?feed=eventsource&since=now&include_docs=true`);
    sourceStud.onmessage = event => {
      const change = JSON.parse(event.data);
      const doc = change.doc;
      if (doc.type === 'chat' && doc.sessionId === getSessionId()) {
        addChatMessageStud(doc.message, !!doc.fromModerator);
      }
    };

    async function sendUserMessage() {
      const message = chatInputStud.value.trim();
      if (!message) return;

      const chatDoc = {
        type: 'chat',
        sessionId: getSessionId(),
        timestamp: new Date().toISOString(),
        fromModerator: false,
        message: message
      };

      try {
        const res = await fetch('http://localhost:5984/gmci', {
          method: 'POST',
          headers: {'Content-Type': 'application/json'},
          body: JSON.stringify(chatDoc)
        });
        if (!res.ok) {
          alert('Fehler beim Senden der Nachricht!');
        } else {
          chatInputStud.value = '';
        }
      } catch(e) {
        alert('Netzwerkfehler beim Senden!');
        console.error(e);
      }
    }

    sendChatBtn.addEventListener('click', sendUserMessage);

    chatInputStud.addEventListener('keypress', e => {
      if(e.key === 'Enter') {
        e.preventDefault();
        sendUserMessage();
      }
    });

    window.onload = () => {
      refresh(); // Erstes Laden der Feedbackfragen
      loadChatsStud(); // Lade auch vorhandene Chatnachrichten
      
      // NEU: Live-Updates f√ºr Session-√Ñnderungen einrichten
      setupSessionLiveUpdates();
    };
  </script>

</body>
</html>