<!DOCTYPE html>
<html lang="de">
<head>
<meta charset="UTF-8" />
<title>Live Dashboard</title>
<style>
  body {
    font-family: Arial, sans-serif;
    max-width: 700px;
    margin: 1rem auto;
    padding: 1rem;
  }
  h1 {
    text-align: center;
  }
  .question-list {
    margin-top: 2rem;
  }
  .question-item {
    background: #f8f9fa;
    border: 1px solid #ccc;
    border-radius: 6px;
    padding: 1rem;
    margin-bottom: 1rem;
    display: flex;
    align-items: center;
    gap: 1rem;
  }
  .question-text {
    flex-grow: 1;
  }
  label {
    cursor: pointer;
  }
  #statusMessage {
    margin-top: 1rem;
    font-weight: bold;
  }
  #chatContainer {
    border: 1px solid #ccc;
    height: 250px;
    overflow-y: auto;
    padding: 10px;
    margin-top: 1rem;
    background: #fafafa;
  }
  #chatInput {
    width: 80%;
    padding: 0.5rem;
    font-size: 1rem;
    box-sizing: border-box;
    border-radius: 4px;
    border: 1px solid #ccc;
  }
  #sendChatBtn {
    padding: 0.5rem 1rem;
    font-size: 1rem;
    cursor: pointer;
    background-color: #2980b9;
    color: white;
    border: none;
    border-radius: 4px;
  }
  #sendChatBtn:hover {
    background-color: #2771a3;
  }
  .chat-message {
    padding: 5px 0;
    border-bottom: 1px solid #eee;
  }
  .answer-count {
    background-color: #e8f4f8;
    padding: 0.3rem 0.6rem;
    border-radius: 12px;
    font-size: 0.9rem;
    font-weight: bold;
    margin-left: 10px;
  }
  .stats-container {
    margin-top: 1rem;
    padding: 0.5rem;
    background-color: #f0f8ff;
    border-radius: 6px;
    border-left: 4px solid #2980b9;
  }
  .stat-bar {
    margin: 0.3rem 0;
  }
  .stat-label {
    font-weight: bold;
    margin-right: 0.5rem;
  }
  .stat-bar-fill {
    display: inline-block;
    height: 20px;
    background-color: #3498db;
    border-radius: 3px;
    margin-right: 0.5rem;
    vertical-align: middle;
  }
  .stat-percentage {
    font-size: 0.9rem;
    color: #666;
  }
  .stat-emoji {
    font-size: 1.2rem;
    margin-right: 0.5rem;
  }
</style>
</head>
<body>

<h1>Live Dashboard</h1>

<div id="sessionTitle"><em>L√§dt ‚Ä¶</em></div>
<div class="question-list" id="questionList"></div>
<div id="statusMessage"></div>

<!-- Chat -->
<h2>Live Chat</h2>
<div id="chatContainer"></div>
<input type="text" id="chatInput" placeholder="Nachricht schreiben..." />
<button id="sendChatBtn">Senden</button>

<script>
  const chatContainer = document.getElementById('chatContainer');
  const chatInput = document.getElementById('chatInput');
  const sendChatBtn = document.getElementById('sendChatBtn');

  const sessionId = new URLSearchParams(window.location.search).get('id');
  if (!sessionId) alert('Keine Session-ID angegeben!');

  // Chatnachricht hinzuf√ºgen
  function addChatMessage(text, fromModerator = false) {
    const msgDiv = document.createElement('div');
    msgDiv.classList.add('chat-message');
    msgDiv.textContent = fromModerator ? `(Moderator) ${text}` : text;
    chatContainer.appendChild(msgDiv);
    chatContainer.scrollTop = chatContainer.scrollHeight;
  }

  // Vorhandene Chatnachrichten laden
  async function loadExistingChats() {
    const mangoQuery = {
      selector: { type: 'chat', sessionId: sessionId },
      sort: [{timestamp: 'asc'}]
    };

    const res = await fetch('http://localhost:5984/gmci/_find', {
      method: 'POST',
      headers: {'Content-Type':'application/json'},
      body: JSON.stringify(mangoQuery)
    });
    const data = await res.json();
    data.docs.forEach(chat => addChatMessage(chat.message, chat.fromModerator));
  }

  // Chatnachricht senden (Moderator)
  async function sendChatMessage() {
    const msg = chatInput.value.trim();
    if (!msg) return alert('Nachricht ist leer');
    const chatDoc = {
      type: 'chat',
      sessionId: sessionId,
      timestamp: new Date().toISOString(),
      fromModerator: true,
      message: msg
    };
    try {
      const res = await fetch('http://localhost:5984/gmci', {
        method: 'POST',
        headers: {'Content-Type':'application/json'},
        body: JSON.stringify(chatDoc)
      });
      if (!res.ok) {
        alert('Fehler beim Senden');
      } else {
        chatInput.value = '';
      }
    } catch(e) {
      alert('Netzwerkfehler');
      console.error(e);
    }
  }

  sendChatBtn.addEventListener('click', sendChatMessage);
  chatInput.addEventListener('keypress', e => {
    if(e.key === 'Enter') {
      e.preventDefault();
      sendChatMessage();
    }
  });

  // Sessionanzeigen, Frage freischalten usw. bleiben unver√§ndert
  const questionList = document.getElementById('questionList');
  const sessionTitleDiv = document.getElementById('sessionTitle');
  const statusMessage = document.getElementById('statusMessage');

  let sessionDoc = null;
  let questionAnswerCounts = {}; // Speichert Antwortzahlen pro Frage

  // ID aus URL auslesen
  function getSessionId() {
    const params = new URLSearchParams(window.location.search);
    return params.get('id');
  }

  async function loadSession() {
    try {
      const res = await fetch(`http://localhost:5984/gmci/${encodeURIComponent(sessionId)}`);
      if (!res.ok) throw new Error(`Session ${sessionId} nicht gefunden`);
      sessionDoc = await res.json();

      sessionTitleDiv.textContent = `Session: ${sessionDoc.title}`;
      renderQuestions();
    } catch (err) {
      sessionTitleDiv.textContent = 'Fehler beim Laden der Session.';
      console.error(err);
    }
  }

  function isQuestionUnlocked(qId) {
    return Array.isArray(sessionDoc.unlockedQuestions) && sessionDoc.unlockedQuestions.includes(qId);
  }

  // In liveDashboard.html, √§ndere saveSessionDoc():
  async function saveSessionDoc() {
    if (!sessionDoc || !sessionDoc._id) return;
    try {
      // Sicherstellen, dass _rev vorhanden ist
      if (!sessionDoc._rev) {
        const currentRes = await fetch(`http://localhost:5984/gmci/${encodeURIComponent(sessionDoc._id)}`);
        if (currentRes.ok) {
          const currentDoc = await currentRes.json();
          sessionDoc._rev = currentDoc._rev;
        }
      }
      
      const res = await fetch(`http://localhost:5984/gmci/${encodeURIComponent(sessionDoc._id)}`, {
        method: 'PUT',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(sessionDoc)
      });
      
      if (!res.ok) {
        const error = await res.json();
        statusMessage.textContent = 'Fehler beim Speichern: ' + (error.reason || res.statusText);
        return false;
      }
      
      const data = await res.json();
      sessionDoc._rev = data.rev;
      statusMessage.textContent = 'Speicherung erfolgreich ‚úî';
      setTimeout(() => statusMessage.textContent = '', 3000);
      
      // NEU: Sofortige Aktualisierung der Studentenseite
      // Wir k√∂nnen das √ºber einen EventSource-Feed l√∂sen
      updateAnswerCounts();
      updateAllStatistics();
      
      return true;
    } catch (e) {
      statusMessage.textContent = 'Netzwerkfehler beim Speichern';
      console.error(e);
      return false;
    }
  }
  // Funktion zum Berechnen der Statistiken
  async function calculateStatistics() {
    if (!sessionDoc || !Array.isArray(sessionDoc.questions)) return;
    
    try {
      // Alle Feedbacks f√ºr diese Session laden
      const feedbackQuery = {
        selector: { 
          type: 'feedback',
          sessionId: sessionId 
        }
      };

      const res = await fetch('http://localhost:5984/gmci/_find', {
        method: 'POST',
        headers: {'Content-Type':'application/json'},
        body: JSON.stringify(feedbackQuery)
      });
      
      const data = await res.json();
      const feedbackDocs = data.docs || [];
      
      // Statistik f√ºr jede Frage berechnen
      const stats = {};
      
      sessionDoc.questions.forEach(question => {
        stats[question.id] = {
          type: question.type,
          totalAnswers: 0,
          answers: {}
        };
        
        // Initialisiere Antworten f√ºr jeden Typ
        switch(question.type) {
          case 'stars':
            for (let i = 1; i <= 5; i++) {
              stats[question.id].answers[i] = 0;
            }
            break;
          case 'emoji':
            stats[question.id].answers['üòû'] = 0;
            stats[question.id].answers['üòê'] = 0;
            stats[question.id].answers['üòÄ'] = 0;
            break;
          case 'multiple-choice':
            if (question.options) {
              question.options.forEach(option => {
                stats[question.id].answers[option] = 0;
              });
            }
            break;
        }
      });
      
      // Feedbacks verarbeiten
      feedbackDocs.forEach(feedback => {
        if (feedback.answers) {
          Object.keys(feedback.answers).forEach(questionId => {
            const answer = feedback.answers[questionId];
            if (stats[questionId]) {
              stats[questionId].totalAnswers++;
              if (stats[questionId].answers.hasOwnProperty(answer)) {
                stats[questionId].answers[answer]++;
              } else if (stats[questionId].type === 'stars' && !isNaN(answer)) {
                // F√ºr Sternebewertung
                stats[questionId].answers[answer]++;
              }
            }
          });
        }
      });
      
      return stats;
      
    } catch (error) {
      console.error('Fehler beim Berechnen der Statistiken:', error);
      return {};
    }
  }

  // Funktion zum Anzeigen der Statistiken
  function displayStatistics(question, stats) {
    const statsContainer = document.getElementById(`stats-${question.id}`);
    if (!statsContainer) return;
    
    const statData = stats[question.id];
    if (!statData) {
      statsContainer.innerHTML = '<p>Keine Statistiken verf√ºgbar</p>';
      return;
    }
    
    let html = '<div class="stats-container">';
    
    switch(statData.type) {
      case 'stars':
        html += '<strong>Sternebewertung:</strong><br>';
        for (let i = 1; i <= 5; i++) {
          const count = statData.answers[i] || 0;
          const percentage = statData.totalAnswers > 0 ? Math.round((count / statData.totalAnswers) * 100) : 0;
          html += `<div class="stat-bar">
            <span>${i}*</span>
            <span class="stat-bar-fill" style="width: ${percentage}%"></span>
            <span class="stat-percentage">${count} (${percentage}%)</span>
          </div>`;
        }
        break;
        
      case 'emoji':
        html += '<strong>Emoji-Bewertung:</strong><br>';
        const emojis = ['üòû', 'üòê', 'üòÄ'];
        emojis.forEach(emoji => {
          const count = statData.answers[emoji] || 0;
          const percentage = statData.totalAnswers > 0 ? Math.round((count / statData.totalAnswers) * 100) : 0;
          html += `<div class="stat-bar">
            <span class="stat-emoji">${emoji}</span>
            <span class="stat-bar-fill" style="width: ${percentage}%"></span>
            <span class="stat-percentage">${count} (${percentage}%)</span>
          </div>`;
        });
        break;
        
      case 'multiple-choice':
        html += '<strong>Multiple Choice:</strong><br>';
        if (question.options) {
          question.options.forEach(option => {
            const count = statData.answers[option] || 0;
            const percentage = statData.totalAnswers > 0 ? Math.round((count / statData.totalAnswers) * 100) : 0;
            html += `<div class="stat-bar">
              <span>${option}</span>
              <span class="stat-bar-fill" style="width: ${percentage}%"></span>
              <span class="stat-percentage">${count} (${percentage}%)</span>
            </div>`;
          });
        }
        break;
    }
    
    html += '</div>';
    statsContainer.innerHTML = html;
  }

  // Funktion zum Aktualisieren aller Statistiken
  async function updateAllStatistics() {
    if (!sessionDoc || !Array.isArray(sessionDoc.questions)) return;
    
    const stats = await calculateStatistics();
    
    sessionDoc.questions.forEach(question => {
      displayStatistics(question, stats);
    });
  }

  function renderQuestions() {
    questionList.innerHTML = '';

    if (!Array.isArray(sessionDoc.questions) || sessionDoc.questions.length === 0) {
      questionList.textContent = 'Keine Fragen vorhanden.';
      return;
    }

    sessionDoc.questions.forEach(question => {
      const div = document.createElement('div');
      div.classList.add('question-item');

      const label = document.createElement('label');
      label.classList.add('question-text');
      label.textContent = question.text;

      // Antwort-Z√§hler hinzuf√ºgen
      const countSpan = document.createElement('span');
      countSpan.id = `answer-count-${question.id}`;
      countSpan.classList.add('answer-count');
      countSpan.textContent = '0 Antworten';

      const checkbox = document.createElement('input');
      checkbox.type = 'checkbox';
      checkbox.checked = isQuestionUnlocked(question.id);
      checkbox.title = 'Frage freischalten/sperren';

      checkbox.addEventListener('change', async () => {
        statusMessage.textContent = 'Speichere √Ñnderung...';
        if (!Array.isArray(sessionDoc.unlockedQuestions)) {
          sessionDoc.unlockedQuestions = [];
        }
        if (checkbox.checked) {
          if (!sessionDoc.unlockedQuestions.includes(question.id)) {
            sessionDoc.unlockedQuestions.push(question.id);
          }
        } else {
          sessionDoc.unlockedQuestions = sessionDoc.unlockedQuestions.filter(id => id !== question.id);
        }
        const success = await saveSessionDoc();
        if (!success) {
          checkbox.checked = !checkbox.checked;
        }
      });

      div.appendChild(label);
      div.appendChild(countSpan); // Z√§hler hinzuf√ºgen
      div.appendChild(checkbox);
      
      // Statistik-Container hinzuf√ºgen
      const statsDiv = document.createElement('div');
      statsDiv.id = `stats-${question.id}`;
      statsDiv.classList.add('stats-container');
      statsDiv.style.marginTop = '1rem';
      statsDiv.innerHTML = '<em>Lade Statistiken...</em>';
      div.appendChild(statsDiv);
      
      questionList.appendChild(div);
    });
    
    // Initialen Z√§hlerstand und Statistiken aktualisieren
    setTimeout(async () => {
      updateAllStatistics();
      updateAnswerCounts();
    }, 100);
  }

  // Funktion zum Z√§hlen der Antworten pro Frage
  async function updateAnswerCounts() {
    if (!sessionDoc || !Array.isArray(sessionDoc.questions)) return;
    
    try {
      // Alle Feedbacks f√ºr diese Session laden
      const feedbackQuery = {
        selector: { 
          type: 'feedback',
          sessionId: sessionId 
        }
      };

      const res = await fetch('http://localhost:5984/gmci/_find', {
        method: 'POST',
        headers: {'Content-Type':'application/json'},
        body: JSON.stringify(feedbackQuery)
      });
      
      const data = await res.json();
      const feedbackDocs = data.docs || [];
      
      // Antwortz√§hler initialisieren
      const counts = {};
      sessionDoc.questions.forEach(question => {
        counts[question.id] = 0;
      });
      
      // F√ºr jedes Feedback die Antworten z√§hlen
      feedbackDocs.forEach(feedback => {
        if (feedback.answers) {
          // Z√§hle f√ºr jede Frage, die in den Antworten vorkommt
          Object.keys(feedback.answers).forEach(questionId => {
            if (counts.hasOwnProperty(questionId)) {
              counts[questionId]++;
            }
          });
        }
      });
      
      // Aktualisiere die Z√§hler in der UI
      sessionDoc.questions.forEach(question => {
        const countElement = document.getElementById(`answer-count-${question.id}`);
        if (countElement) {
          countElement.textContent = `${counts[question.id]} Antworten`;
        }
      });
      
      // Speichere die Z√§hler f√ºr sp√§ter
      questionAnswerCounts = counts;
      
    } catch (error) {
      console.error('Fehler beim Z√§hlen der Antworten:', error);
    }
  }

  // Live-Updates √ºber Changes Feed
  function setupLiveFeedbackUpdates() {
    const source = new EventSource(`http://localhost:5984/gmci/_changes?feed=eventsource&since=now&include_docs=true`);
    source.onmessage = event => {
      const change = JSON.parse(event.data);
      const doc = change.doc;
      
      if (doc.type === 'feedback' && doc.sessionId === sessionId) {
        // Aktualisiere die Z√§hler und Statistiken, sobald neue Feedbacks kommen
        console.log('Neues Feedback erhalten, aktualisiere Z√§hler und Statistiken...');
        updateAnswerCounts();
        updateAllStatistics();
      }
      
      if (doc.type === 'chat' && doc.sessionId === sessionId) {
        addChatMessage(doc.message, !!doc.fromModerator);
      }
    };
  }

  // Initialisiere Live-Updates
  window.onload = () => {
    loadExistingChats();
    loadSession();
    setupLiveFeedbackUpdates(); // Live-Updates aktivieren
  };
</script>

</body>
</html>